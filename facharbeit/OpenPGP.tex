\documentclass[12pt]{article}
\usepackage[german]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{xcolor}
\usepackage{setspace}
\usepackage[margin=2cm,left=4cm,marginparwidth=3cm]{geometry}
\usepackage{listings}
\usepackage{float}
\reversemarginpar

\lstset{
language=Python,
numbers=left,
keepspaces=true,
keywordstyle=\color{blue},
morekeywords={assert},
basicstyle=\footnotesize\ttfamily,
numberstyle=\tiny\color{gray},
title=\lstname,
captionpos=b,
}

\newfloat{code-snip}{htbp}{what_is_this}
\floatname{code-snip}{Quellcodeausschnitt}

% https://tex.stackexchange.com/a/30114
\setstretch{1.241}

\newcommand{\todo}[1]{\textcolor{red}{\mbox{TODO}}\marginpar{\textcolor{red}{#1}}}
\newcommand{\floor}[1]{\lfloor #1 \rfloor}

% https://tex.stackexchange.com/questions/23957/how-to-set-font-to-arial-throughout-the-entire-document
\renewcommand{\rmdefault}{phv} % Arial
\renewcommand{\sfdefault}{phv} % Arial

\title{Mathematische Hintergr\"unde und praktische Anwendung asymmetrischer Kryptographie am Beispiel von RSA und OpenPGP}
\input{pii.tex}

\begin{document}
\maketitle
\thispagestyle{empty}
\newpage
\tableofcontents
\newpage

\section{Einleitung}
% Asymmetrische Kryptographie ist toll. Damit kann man vieles machen (verschl"usseln, unterschreiben). [Bild von Wikipedia] Im "`digitalen Zeitalter"' ist das wichtig. (TLS, IoT). OpenPGP (Phil Zimmermann) ist neben S/MIME das Standardprotokoll f"ur krypto-behandelte E-Mails, hat aber auch z.B. WoT. Ich habe einen Teil davon implementiert.

\todo{Brauche ich f"ur diese Sachen Zitate?}

Traditionell waren Verschl"usselungsverfahren "`symmetrisch"', d.h., dass wie bei einem physischen Schloss
der gleiche Schl"ussel zum Verschlie"sen (Verschl"usseln) und zum Aufschlie"sen (Entschl"usseln) verwendet wird.
Der Ver\-schl"us\-sel\-ungs\-pro\-zess ist im Laufe der Zeit komplizierter geworden
(von der auch im Kopf m"oglichen Caesar-Verschl"usselung bis zur
maschinellen Verschl"usselung der Enigma w"ah\-rend des zweiten Weltkriegs),
jedoch hat es nie bis zuletzt
eine Abweichung vom Konzept eines einzigen Schl"ussels f"ur Ver- und Entschl"usselung gegeben.

Nach Entwicklung der Vorl"aufer des heutigen Internets wurde dann die asymmetrische Kryptographie erfunden.
Hier werden f"ur Ver- und Entschl"usselung separate Schl"ussel verwendet
(wie bei einem Vorh"angeschloss, wenn man das Schlie"sen als "`"offentlichen Schl"ussel"' betrachtet),
sodass Menschen verschl"usselt kom\-mu\-ni\-zie\-ren k"onnen, ohne vorher einen gemeinsamen Schl"ussel auszutauschen.
Neben Verschl"usselung von Nachrichten kann das Konzept asymmetrischer Kryptographie
auch f"ur digitale Unterschriften verwendet werden.

Der erste solche Verschl"usselungsalgorithmus, der auch in der Lage ist, Unterschriften zu erstellen und zu verifizieren, ist RSA.
Diesen m"ochte ich in dieser Arbeit n"aher betrachten und auch selbst implementieren.
RSA wird weiterhin in verschl"usselten Verbindungen mit gr"o"seren Seiten
wie etwa \texttt{wikipedia.org}, \\ \texttt{google.com} oder \piibigsite{} verwendet%
\footnote{Obwohl sowohl Google als auch Wikipedia inzwischen ECC-Schl"ussel verwenden,
sind die Schl"ussel der entsprechenden Root-CAs noch immer RSA-2048 (Stand \today)}.

Neben dieser Anwendung in TLS (der Kryptographie-Komponente\footnote{
TLS ist trotz dieser massiven Anwendung im WWW ein separates Protokoll und wird auch z.B. f"ur SMTPS oder FTPS (nicht mit SFTP zu verwechseln, welches "uber SSH l"auft) verwendet}
von HTTPS, dem Protokoll f"ur das WWW) wird RSA auch in OpenPGP,
welches auf dem 1991 von Phil Zimmermann ver"offentlichten PGP basiert und Einsatz bei der Ende-zu-Ende-Verschl"usselung
(d.h., dass nur Sender und Empf"anger den Inhalt lesen k"on\-nen)
von E-Mails findet, zur Verschl"usselung und f"ur Unterschriften verwendet.
W"ah\-rend sich OpenPGP auch mit der Vernetzung von Schl"usseln im Sinne eines sog.\@ "`Web of Trust"' befasst,
habe ich mich bei meiner Teilimplementation haupts"achlich auf die durch RSA m"oglich gemachten
Funktionalit"aten konzentriert\footnote{Wobei nat"urlich Unterschriften "uber Schl"ussel f"ur das WoT wichtig sind, und ich somit diesen Teilaspekt mitimplementiert habe}.

\section{Mathe hinter RSA}
%Nachrichten und Schl"ussel sind Zahlen.
%Hier wahrscheinlich sehr viel aus dem RSA-Paper zitieren.

Mathematisch betrachtet man eine Nachricht als eine Zahl und einen
Ver\-schl"us\-sel\-ungs\-al\-go\-rith\-mus als zwei Funktionen.
Eine, im Folgenden $E(m)$, verwandelt unter Zuhilfenahme eines Schl"ussels eine
Nachricht in chiffrierten Text, eine zweite, im Folgenden $D(c)$,
verwandelt unter Zuhilfenahme eines anderen Schl"ussels -- dies ist der asymmetrische Teil --
den chiffrierten Text in die urspr"ungliche Nachricht.
Es gilt also $m = D(E(m))$.
Anders ausgedr"uckt: $D$ ist Umkehrfunktion von $E$~\cite{rsa}.
\todo{Hier irgendwo auch Unterschriften erw"ahnen?}

\subsection{Wie Schl"ussel aussehen}
\label{subsec:rsa:keys}
%Verh"altnis zwischen "offentlichem und privaten Exponenten.

Ein "offentlicher Schl"ussel besteht aus einem Paar nat"urlicher Zahlen $(e, n)$,
ein privater aus einem Paar nat"urlicher Zahlen $(d, n)$.
Dabei gilt, dass $n = pq$, das Produkt zweier ausreichend gro"ser Primzahlen~\cite{rsa}.

F"ur $e$ und $d$ gilt aus nachfolgend genannten Gr"unden, dass $ed \equiv 1 \mod \phi(n)$,
wobei $\phi$ die eulersche Phi-Funktion darstellt, die nachfolgend n"aher erl"autert wird~\cite{rsa}.
Damit diese Kongruenz gelten kann, m"ussen $e$ und $d$ relativ prim zu $\phi(n)$ sein.
Dies kann mittels des Widerspruchsbeweises gezeigt werden:
Wenn $d$ (analog f"ur $e$) einen gemeinsamen Faktor $f > 1 \in \mathbb{N}$ mit $\phi(n)$ teilte, m"usste Folgendes gelten:
\[
\begin{aligned}
&d = fa ~~;~~ \phi(n) = fb && \textrm{ mit } a, b \in \mathbb{N} \\
&efa \equiv 1 \mod fb \\
&efa = kfb + 1 && \textrm{f"ur ein bestimmtes } k \in \mathbb{N} \\
&ea = kb + \frac{1}{f} & \lightning &
\end{aligned}
\]
Da $ea$ und $kb$ als Produkte nat"urlicher Zahlen ebenfalls nat"urliche Zahlen sind, $\frac{1}{f}$ jedoch nicht, kommt es zum Widerspruch.
Somit sind $e$ und $d$ relativ prim zu $\phi(n)$.

Um ein Zahlenpaar zu finden, welches diese Eigenschaften hat,
ist es am einfachsten, einen geeigneten Wert f"ur $e$ festzulegen (z.B.\@ 65537)
und dann mittels des erweiterten Euklidschen Algorithmus (s.~unten) $d$ zu berechnen.

\subsubsection{Die eulersche Phi-Funktion}
Die eulersche Phi-Funktion $\phi(n)$ ordnet einer nat"urlichen Zahl $n$ die Anzahl
der nat"urlichen Zahlen kleiner gleich $n$, die relativ prim zu $n$ sind, zu.
F"ur eine Primzahl $p$ ist trivialerweise $\phi(p) = p-1$,
da jede nat"urliche Zahl unter $p$ per Definition keine Faktoren bis auf $1$ mit $p$ teilt.
F"ur ein Produkt zweier Primzahlen $p$ und $q$ ist nach Euler
$\phi(pq) = \phi(p) \cdot \phi(q) = (p-1)(q-1)$~\cite{euler63}.

\subsubsection{Der erweiterte Euklidsche Algorithmus}
Der einfache Euklidsche Algorithmus kann zur Berechnung des gr"o"sten gemeinsamen
Teilers zweier Zahlen $a, b$ verwendet werden.
Speichert man einige weitere Zahlen, erh"alt man auch zwei ganze Zahlen $s, t$, sodass
$sa + tb = ggt(a, b)$~\cite{taocp2}.

Der Algorithmus selbst besteht (bei geeigneter Z"ahlweise) aus drei Schritten.
Eingaben sind zwei nat"urliche Zahlen $a_0 > b_0$~\cite{taocp2}:
\begin{enumerate}
    \item Setze $s_1 \gets 1$, $s_2 \gets 0$, $t_1 \gets 0$, $t_2 \gets 1$, $a \gets a_0$, $b \gets b_0$
    \item Falls $b = 0$: Beende, der GGT ist $a$ und $s_1 a_0 + t_1 b_0 = a$
    \item Berechne $q = \floor{\frac{a}{b}}$ und setze zeitgleich:
    \begin{itemize}
        \item $a \gets b$, $b \gets a - bq$
        \item $s_1 \gets t_2$, $s_2 \gets s_1 - s_2 q$
        \item $t_1 \gets t_2$, $t_2 \gets t_1 - t_2 q$
    \end{itemize}
\end{enumerate}\cite{taocp2}

\paragraph{Beispiel nach~\cite{taocp2}}\todo{Lieber eigenes Beispiel?}
~\\
Mit $a_0 = 40902$ und $b_0 = 24140$.
Dargestellt ist jeweils der Stand nach Ausf"uhrung des zweiten Schritts.

\begin{tabular}{c|c c c c c c c l}
    Iteration-Nr. & $q$ & $s_1$ & $t_1$ & $a$ & $s_2$ & $t_2$ & $b$ \\
    \hline
    1 & -- & 1 & 0 & 40902 & 0 & 1 & 24140 \\
    2 & 1 & 0 & 1 & 24140 & 1 & -1 & 16762 \\
    3 & 1 & 1 & -1 & 16762 & -1 & 2 & 7378 \\
    4 & 2 & -1 & 2 & 7378 & 3 & -5 & 2006 \\
    5 & 3 & 3 & -5 & 2006 & -10 & 17 & 1360 \\
    6 & 1 & -10 & 17 & 1360 & 13 & -22 & 646 \\
    7 & 2 & 13 & -22 & 646 & -36 & 61 & 68 \\
    8 & 9 & -36 & 61 & 68 & 337 & -571 & 34 \\
    9 & 2 & 337 & -571 & 34 & -710 & 1203 & 0 \\
\end{tabular}
~\\~\\
\noindent
Tats"achlich ist $337 \cdot 40902 - 571 \cdot 24140 = 34 = ggt(40902, 24140)$~\cite{taocp2}.

\paragraph{Verwendbarkeit f"ur RSA}

Um ein $d$ zu bestimmen, wenn $ed \equiv 1 \mod \phi(n) $ und $e$ sowie $\phi(n)$ bekannt (bzw.\@ gew"ahlt) sind,
kann der erweiterte Euklidsche Algorithmus auf $e$ und $\phi(n)$ angewandt werden.
Weil $\phi(n)$ und $e$ wie oben gezeigt relativ prim zueinander sind, ist ihr GGT gleich eins.
Somit gilt f"ur die beiden weiteren vom Algorithmus ausgegebenen Zahlen $s, t$, dass $se + t\phi(n) = 1$.

\noindent Mit diesen Grundagen k"onnen die folgenden "Aquivalenzen aufgestellt werden:
\[\begin{aligned}
      &ed &\equiv&~1 \mod \phi(n)& \\
      \iff&ed &=&~1 + k \phi(n) &\textrm{f"ur ein }k \in \mathbb{Z}\\
      &&=&~xe + y\phi(n) + k\phi(n)& \\
      &&=&~xe + (y+k)\phi(n) &\\
      \iff& ed &\equiv&~xe \mod \phi(n) &\textrm{da }y+k\textrm{ eine ganze Zahl ist}\\
      \iff& d &\equiv&~x \mod \phi(n)
  \end{aligned}
\]

\subsection{Ver-/Entschl"usselungsprozess}
% Das hier wird wahrscheinlich "Uberschneidungen mit "`Wie Schl"ussel aussehen"' haben.
F"ur die Ver- und Entschl"usselungsfunktionen gilt~\cite{rsa}:
\[
\begin{aligned}
E(m) = m^e \mod n \\
D(c) = m^d \mod n
\end{aligned}
\]

Die G"ultigkeit dieser Funktionen wird nun erl"autert. \todo{So oder and\-ers\-her\-um?}

Nach Euler gilt $a^{b-1} \equiv 1 \mod b$ f"ur alle $b \in \mathbb{P}$ und $a \in \mathbb{N}$,
wenn $a$ nicht durch $b$ teilbar ist, also $a \not\equiv 0 \mod b$~\cite{euler41}.
Da $p$ (Faktor von $n$, s.~Abs.~\ref{subsec:rsa:keys}) prim ist,
gilt offensichtlich $a^{p-1} \equiv 1 \mod p$
(f"ur ein beliebiges $a$ wie oben beschrieben) und somit $m \cdot a^{p-1} \equiv m \mod p$.

Setzt man f"ur $a$ den Wert $m^{k \cdot (q-1)}$ ein,
wobei $k$ eine folgend n"aher bestimmte nat"urliche Zahl, $q$ der zweite Faktor von $n$
und $m$ eine die Nachricht darstellende nat"urliche Zahl ist,
erh"alt man f"ur die linke Seite der Kongruenz~\cite{rsa}:
\[
    m \cdot \left(m^{k(q-1)}\right)^{p-1} = m \cdot m^{k(q-1)(p-1)} = m \cdot m^{k\phi(n)} = m^{k\phi(n) + 1}
\]
Die gesamte Kongruenz lautet also $m^{k\phi(n)+1} \equiv m \mod p$.

Diese Kongruenz gilt weiterhin nur f"ur $m^{k(q-1)} \not\equiv 0 \mod p$.

Wenn $m^{k(q-1)} \equiv 0 \mod p$, ist $p$ Teiler von $m^{k(q-1)}$.
Da $m^{k(q-1)}$ nicht mehr verschiedene Faktoren als $m$ hat und $p$ als Primzahl
genua einen Primfaktor hat, teilt $p$ auch $m$.
Als Kongruenz gescgrieben hei"st das: $m \equiv 0 \mod p$.
Es gilt also $m^{k(q-1)} \equiv 0 \equiv m \mod p$.
Somit gilt $m^{k\phi(n)+1} \equiv m \mod p$ f"ur alle $m \in \mathbb{N}$~\cite{rsa}.\todo{So OK?}

Da aus $ed \equiv 1 \mod \phi(n)$ folgt, dass $ed = k\phi(n) +1$ f"ur ein $k \in \mathbb{N}$,%
\footnote{Da $e, d$ und $\phi(n)$ nat"urliche Zahlen sind, ist $k$ in diesem Fall auch nat"urlich}
gilt $m^{ed} \equiv m \mod p$.
Analog (durch Vertauschen von $p$ und $q$) kann gezeigt werden,
dass $m^{ed} \equiv m \mod q$ gilt~\cite{rsa}.

Aus diesen Kongruenzen lassen sich die folgenden beiden Gleichungen ableiten,
wobei $a, b \in \mathbb{N}$:

\[
\begin{aligned}
ap + m = m^{ed} \land ~~~ bq + m = m^{ed} \\
\iff m^{ed} - m = ap = bq
\end{aligned}
\]

Da $p$ und $q$ als Primzahlen keine Faktoren teilen, folgt aus $ap = bq$,
dass $a$ durch $q$ teilbar ist und $b$ durch $p$ teilbar ist.
Setzt man $c = \frac{a}{q} = \frac{b}{p}$ ($c \in \mathbb{N}$),
sieht man, dass $cn = m^{ed} - m$~\cite{pii1}.
Schreibt man diese Gleichung als Kongruenz, erh"alt man:

\[
m^{ed} \equiv m \mod n
\]

An dieser letzten Kongruenz sieht man, dass $D(E(m)) = (m^e)^d = m^{ed} \equiv m$,
die Ver- und Entschl"usselungsfunktionen also tats"achlich funktionieren.

\subsection{Cool! Damit kann man auch unterschreiben}

Die Ver- und Entschl"usselungsfunktionen lassen sich offensichtlich
auch verkehrt herum anwenden, ohne dass es zu Problemen kommt:
\[D(E(m)) = (m^e)^d = m^{ed} = (m^d)^e = E(D(m))\]
Obwohl dies zur Aufbewahrung geheimer Informationen offensichtlich suboptimal ist,
da der "offentliche Schl"ussel "offentlich sein soll, k"onnen damit Unterschriften erstellt werden.
Da nur jemand mit Zugang zu einem privaten Schl"ussel $s = D(m)$ berechnen kann,
kann man durch $E(s) = m$ verifizieren, dass $m$ tats"achlich vom
Inhaber des privaten Schl"ussels verschickt wurde.

\subsection{Sicherheit}

Kennt man die Faktoren $p$ und $q$, kann man leicht $\phi(n)$ und somit auch $d$ berechnen.
Die Faktorisierung wird jedoch schon seit Jahrtausenden untersucht,
ohne dass eine effiziente Methode gefunden wurde%
\footnote{f"ur Quantencomputer existieren effiziente Algorithmen,
jedoch wurden keine ausreichender Gr"o"se gebaut}~\cite{rsa}. \todo{Reichen die Beispiele hier?}

Die Berechnung von $\phi(n)$, ohne "uber die Faktoren zu gehen,
kann wie folgt in Kenntnis von $p$ und $q$ umgewandelt werden, sodass die Berechnung von $\phi(n)$
und die Faktorisierung $n$s \todo{Besser aussehen lassen} "aquivalent sind:

Kennt man $\phi(n)$, kann man "uber $\phi(n) = (p-1)(q-1) = n - (p+q) + 1$
die Summe $p+q$ berechnen.
Danach kann man mit $(p+q)^2 = p^2 + 2n + q^2 = p^2 - 2n + q^2 + 4n = (p-q)^2 + 4n$
die Differenz $p-q$ und folgend $q = \frac{(p+q) - (p-q)}{2}$ berechnet werden.
Dadurch hat man die Faktoren von $n$ berechnet~\cite{rsa}.

Trotz der "Aquivalenz zur Faktorisierung in diesem (und einigen weiteren,
hier nicht aufgef"uhrten F"allen, die in~\cite{rsa} genannt werden),
ist nicht automatisch jede Methode, die RSA bricht, eine M"oglichkeit
zur Faktorisierung~\cite{sinews}.
\todo{Die Quelle bezieht sich auf doi:10.1.1.73.7840, lieber direkt zitieren?}

\section{RSA praktisch implementieren}
% Bytes kann man einfach in Zahlen umwandeln, aber es geh"ort noch etwas mehr dazu

Ein offensichtlicher Unterschied zwischen den mathematischen Funktionen,
die RSA ausmachen, und praktischer Anwending ist, dass man praktisch entweder Dateien
oder Text und nicht Zahlen verschl"usseln will.
Dies ist jedoch nur das leichteste Problem, wenn RSA praktisch implementiert werden soll.
\todo{Mehr intro?}

\subsection{Effiziente Berechnung von $a^b \mod n$}
% Sonst w"are das alles viel zu langsam.

Da man sowohl zum Ver- als auch zum Entschl"usseln $a^b \mod n$ berechnen muss,
jedoch die jeweiligen Exponenten ($e$, $d$) in den allermeisten F"allen
in der Gr"o"senordnung von mindestens f"unf Stellen liegen
(der meistgenutzte "offentliche Exponent ist 65537%
\footnote{In GnuPG und OpenSSl Defaultwert,
und in \emph{jedem} RSA-Zertifikat, welches ich gesehen habe}),
ist es notwendig, modulare Exponentiation zu optimieren,
damit Ver- und Entschl"usselung praktikabel wird.

Um modulare Exponentiation zu verschnellern, kann man entweder weniger Multiplikationen
als $b-1$ durchf"uhren oder die durchgef"uhreten Multiplikationen schneller durchf"uhren.
Nat"urlich ist auch beides gleichzeitig m"oglich~\cite{hac}.

Ein allgemeiner Ansatz, Exponentiation zu verschnellern, ist sog.\@
"`repeated square and multiply"' ("`wiederholtes Quadrieren und Multiplizieren"').
In der einfachsten Form werden dabei alle $a^{(2^i)}$ multipliziert,
f"ur die das $i$te Bit in der binaren Darstellung von $b$ gleich $1$ ist.
Da man die Werte $a^{(2^i)}$ erhalten kann, indem man in jedem Schritt $a$ quadriert,
und die Multiplikationen auch schrittweise erfolgen k"onnen, (s.\@ Quellcodeausschnitt~\ref{code:square-and-multiply})
wird hier wiederholt quadriert und multipliziert.
Von diesem grundlegenen Algorithmus existieren Abwandlungen,
die durch noch weniger Multiplikationen mehr Effizienz erreichen.
Diese beschreibe ich allerdings nicht hier~\cite{hac}. \todo{Anhang?}

\begin{code-snip}
\begin{lstlisting}
def square_and_multiply_simple(a, b):
    ergebnis = 1
    for i in range(x.bit_length()):
        if 1 & b:
            ergebnis *= a
        a **= 2
        b >>= 1
    return ergebnis
\end{lstlisting}
\caption{Implementation eines simplen square-and-multiply-Algorithmus nach~\cite{hac}}
\label{code:square-and-multiply}
\end{code-snip}

Baut man die modulare Reduktion in die Multiplikation ein,
bleiben die zu multiplizierenden Zahlen klein, sodass die einzelnen
Multiplikationen schneller werden.
Auch hier existiert eine optimierte Variante, die sog.\@ "`Montgomery-Reduktion"'.
Dabei wird f"ur zwei ganze relativ prime Zahlen $m$ und $r$ sowie eine ganze Zahl $t$ mit $0 \leq t \le mr$
die kleinste nat"urliche Zahl, die kongruent zu $tr^{-1} \mod m$ ist, berechnet.
Dies kann bei man geschickter Wahl der zu multiplizierenden Zahlen
bei optimierten square-and-multiply-Algorithmen einsetzen.
\todo{Genau wie? Braucht aber ltr-algo}

In Python ist eine optimierte modulare Exponentiation als \lstinline{pow(a, b, n)} eingebaut.

\subsection{Primzahlen finden}
% Vielleicht den Teil hier auch in den Matheteil schieben. Auf jeden Fall im Anhang andere M"oglichkeiten auflisten.
Um Schl"ussel zu generieren, braucht man zun"achst Primzahlen.
Um diese Primzahlen zu erhalten, ist es aufgrund der Gr"o"se
(ab ca.\@ 1024 bits bzw.\@ 308 Ziffern)
inpraktikabel (darauf beruht die Sicherheit), alle Primzahlen zu finden.
Daher sieht die Prozedur zur Primzahlengeneration wie folgt aus~\cite{hac}: \todo{Fast 1 zu 1 "ubersetzt. Anders formatieren?}
\begin{itemize}
    \item Zuf"allige Zahl der gew"unschten Gr"o"se generieren
    \item Pr"ufen, ob die Zahl prim ist
    \item Fortfahren, bis eine Primzahl gefunden wurde
\end{itemize}

Zur Pr"ufung einer Primzahl existieren viele verschiedene Algorithmen.
Sie lassen sich grob in zwei Gruppen einteilen:
die probabilistischen, die mehrfach pr"ufen, ob eine Zahl zusammengesetzt ist,
und nach einer bestimmten Anzahl an Wiederholungen annehmen, dass die Zahl prim ist,
und die "`echten"', die tats"achlich beweisen k"onnen, dass eine Zahl prim ist~\cite{hac}.

Letztere sind generell komplexer, zeitaufw"andiger und funktionieren tw.\@ nur
f"ur spezielle Zahlen.
Zufallsabh"angige Tests k"onnen durch Wahl einer geeigneten Wiederholungszahl
auch hochverl"asslich gemacht werden.
Auch ist es m"oglich, ein hybrides Verfahren verwenden,
indem man zun"achst mit probabilistischen Tests
wahrscheinliche Primzahlen findet und dann mit komplexeren Tests
diese wenige Zahlen pr"uft~\cite{hac}.

\subsubsection{Der Miller-Rabin-Test}
Der Miller-Rabin-Test ist ein probabilistischer test, der "`nur"' beweisen kann,
dass eine Zahl zusammengesetzt ist.
Daf"ur wird die Tatsache verwendet, dass f"ur eine Primzahl $p = 2^s r+1$ und eine
zu $p$ relativ prime ganze Zahl entweder $a^r \equiv 1 \mod p$ oder
$a^{(2^j)r} \equiv -1 \mod p$ f"ur ein $j$ mit $0 \leq j \leq s-1$~\cite{hac}.

Man pr"uft nun f"ur zuf"allig gew"ahlte $a$, ob eine der Kongruenzen gilt.
Dabei kann wegen $a^{(2^j)r} = (a^r)^(2^j)$ w"ahrend der "Uberpr"ufung von
$a^{(2^j)r} \equiv -1 \mod p$ der Initialwert $a^r$ bei Erh"ohung von $j$ einfach quadriert werden,
sodass insgesamt weniger Rechnungen ben"otigt werden~\cite{hac}.
Gilt keine der Kongruenzen, wird angenommen, dass die Zahl prim ist.
F"ur eine ungerade zusammengesetzte Zahl $n$ gilt,
dass maximal $\frac{1}{4}$ der Zahlen $a$ mit $2 \leq a \leq n-1$ die Kongruenzen nicht erf"ullen,
d.h., dass f"alschlicherweise eine Primzahl angenommen wird.
W"ahlt man $a$ zuf"allig, sinkt die Wahrscheinlichkeit, zusammengesetzte Zahlen als prim zu erkennen,
mit jedem $a$ um Faktor $\frac{1}{4}$, also exponentiell.
W"ahlt man $t$ Wiederholungen, betr"agt die Wahrscheinlichkeit, eine zusammengesetzte Zahl nicht als solche zu erkennen,
$\left(\frac{1}{4}\right)^t = \frac{1}{2^{2t}}$~\cite{hac}.

\subsection{Der PKCS\#1-Standard}
% Warum man Padding benutzt. Entweder nur die f"ur OpenPGP benutzten Teile oder alles. Vielleicht auch nur die vorletzte Version.

Auch wenn RSA wie oben beschrieben als sicher angenommen wird, kann es in der praktischen
Anwendung beispielsweise bei kurzen Nachrichten zu Sicherheitsl"ucken kommen~\cite{sinews}.\todo{Auch komplett zitieren?}
Um dies zu verhindern, wurde der sog.\@ Public-Key Cryptography Standard \#1 geschrieben,
der das Format einer mit RSA Verschl"usselten Nachricht sowie einer RSA-Unterschrift festlegt.

Da fr"uhere Versionen nicht gegen alle Angriffe immun waren, ist der Standard
im Laufe der Zeit weiterentwickelt worden~\cite{sinews}.
OpenPGP basiert jedoch noch auf Version 1.5, sodass ich im Folgenden diese Version erl"autere~\cite{rfc4480}.

Vor dem Verschl"usseln wird eine Nachricht mit den Bytes \verb|00 02|
(zur Erkennung, dass die Nachricht wie folgt foratiert ist),
so vielen nicht genullten Bytes wie m"oglich (sodass der Gesamtwert unter $n$ bleibt)
und einen \verb|00|-Byte (um das Ende der zuf"allien Bytes zu erkennen) pr"afixiert.
Dies vergr"o"sert die der Nachricht entsprechende Zahl und verhindert,
dass kurze Nachrichten Sicherheitsprobleme darstellen~\cite{rfc4480,sinews}.

Bei Unterschriften wird nicht die zu unterschreibende Nachricht selbst,
sondern ein sog.\@ "`hash"' oder "`Streuwert"', ein der Nachricht eindeutig zugeordneter Wert,
der idealerweise (sonst k"onnen Unterschriften gef"alscht werden) m"oglichst kollisionsresistent ist,
mathematisch unterschrieben.
Auch hierbei werden zus"atzliche Bytes angef"ugt: erst \verb|00 01|, dann zuf"allig gew"ahlte, nicht genullte Bytes,
\verb|00| und, zus"atzlich zum Format f"ur Verschl"usselung, eine den Hashalgorithmus identifizierende konstante Bytefolge.

Die so erhaltene Unterschrift muss zus"atzlich zur Nachricht "ubertragen werden,
da einerseits man sonst nicht die Nachricht bekommt, andererseits die Nachricht
ben"otigt wird, um den Hashwert zu berechnen.

\subsection{Meine Implementation}
\subsubsection{Primzahlen}
Zum Finden der ben"otigten Primzahlen verwende ich den Miller-Rabin-Algorithmus.

Die Werte von $r$ und $s$ f"ur $n = 2^s r + 1$ finde ich, indem ich soweit wie m"oglich
$n - 1$ fortlaufend durch zwei teile und einen Z"ahler erh"ohe.

F"ur die Primzahlpr"ufung an sich verwende ich den Algorithmus wie in~\cite{hac} beschrieben.
Dabei wende ich die bereits beschriebene Optimierung der einzelnen Quadratur pro Schritt an.
Zu beachten ist, dass die Modulo-Funktion bzw.\@ der \lstinline{\%}-Operator
die kleinste positive die entsprechende Kongruenz erf"ullende Zahl zur"uckgeben,
weshalb die Tests $z \equiv -1 \mod n$ als \lstinline{z \% n == n-1} geschrieben werden m"ussen.

Als Wiederholungszahl habe ich 128 festgelegt.
So ist die Wahrscheinlichkeit, dass eine zusammengesetzte Zahl als prim erkl"art wird,
$\frac{1}{2^{256}}$, was der Wahrscheinlichkit entspricht, einen AES-256%
\footnote{Der symmetrische Algorithmus, der u.a.\@ von den USA f"ur streng geheime Informationen verwendet wird}%
-Schl"ussel beim ersten Versuch zu erraten.

\todo{Quellcode hier einf"ugen?}

\subsubsection{Schl"usselerstellung}
Mit gefundenen Primzahlen erstelle ich "uber die im mathematischen Teil genannten Schritte
dann den "offentlichen und privaten Schl"ussel.
Auch hier muss auf negative Werte (als Ergebnis des erweiterten Euklidschen Algorithmus)
achtgegeben werden: Um einen postiven Wert f"ur $d$ zu erhalten, der die ben"otigte Kongruenz
$ed \equiv 1 \mod \phi(n)$ erf"ullt, kann hier die Modulufunktion bzw.\@ der \verb|%|-Operator
verwendet werden.
Dabei lege ich f"ur $e$ 65537 fest.
Die Berechnung von $\phi(n)$ ist ebenfalls direkt als $n - p - q + 1$ implementiert.

\subsubsection{Ver- und Entschl"usselung, Unterschriften}
Der grundlegene Ver- und Entschl"usseldungsprozess ist buchst"ablich:
\lstinputlisting[firstnumber=57,firstline=57,lastline=59]{../openpgp/rsa.py}
Da in jeder Verwendung Bytes verwendet werden, habe ich daf"ur eine die Konvertierung
durchf"uhrende Wrapperfunktion, \lstinline{crypt_bytes}, geschrieben.

F"ur Ver- und Entschl"usselung habe ich die entsprechenden En- und Dekodierungsverfahren
aus dem Standard implementiert.
Die Unterschriften (sowohl Erstellung als auch Verifizierung) nahmen direkt den
pr"akixierten Hash als Parameter.
Bei den Unterschriften ist anzumerken, dass es nur eine Enkodierung gibt,
da bei der Verifikation der entschl"usselte Wert mit dem kodierten Hash verglichen wird.

\section{OpenPGP}
\subsection{"Ubersicht}
%Was macht OpenPGP?
%Wahrscheinlich viel aus dem OpenPGP-Standard zitieren. Vielleicht finde ich auch noch etwas deskriptives au"ser Wikipedia.

Im Jahre 1991 ver"offentlichte\footnote{Aufgrund von rechtlichen Problemen
(Exportbeschr"ankungen sowie Patentrechte der RSA Data Security) bestand die Ver"offentlichung daraus,
dass ein Freund Zimmermanns die Software in einem Internet-Forum postete}
Phil Zimmermann PGP ("`Pretty Good Privacy"'),
um die bis dahin nur Regierungen und gro"sen Unternehmen verf"ugbare RSA-Verschl"usselung
auch f"ur die allgemeine Bev"olkerung praktikabel zu machen,
indem er die komplexen Prozesse, die f"ur Schl"usselerstellung,
Verschl"usselung von Nachrichten, digitale Unterschriften und Verwaltung von Schl"usseln
notwendig sind, vereinfachte.
Dabei dachte er vor allem an die Verwendung f"ur E-Mails~\cite{singh}.

\todo{Zu viele "Uberschneidungen mit der Einleitung?}
Auf Basis der PGP-Software ist inzwischen der OpenPGP-Standard geschaffen worden,
der neben S/MIME (Secure/Multipurpose Internet Mail Extensions)
eines der Hauptformate f"ur verschl"usselte und unterschriebene E-Mails ist.
Trotz dieser starken Nutzung eigent sich OpenPGP durchaus f"ur die Verschl"usselung
von station"aren Daten.
Es gibt ebenfals einen Modus f"ur symmetrische Verschl"usselung mit Passwort~\cite{rfc4480}.

Der asymmetrische Verschl"usselungsmodus besteht tats"achlich aus einer sog.\@ "`hybriden"'
Verschl"usselung \todo{Bild?}, d.h.\@, dass die eigentlichen Daten zun"achst symmetrisch verschl"usselt werden
und dann der symmetrische Schl"ussel asymmetrisch verschl"usselt wird.
OpenPGP erlaubt so die gleichzeitige Verschl"usselung an mehrere Empf"anger%
\footnote{In parktischer Anwendung bei E-Mails wird man als Absender auch sich selbst
als Empf"anger eintragen bzw.\@ dies automatisch durch die Software machen lassen,
damit man auch verschickte E-Mails lesen kann.}
und die bereits erw"ahnte Passwort-Verschl"usselung~\cite{rfc4480}.
\todo{Spezifische Beispiele f"ur Alogrithmen?}

Neben Unterschriften "uber Daten sieht OpenPGP auch Unterschriften "uber Schl"ussel vor,
die entweder einem Hauptschl"ussel erlauben, Unterschl"ussl an sich zu binden oder
einer Person erlauben, die Genauigkeit einer "`User ID"', also der Zuordnung eines Schl"ussels
zu einer realen Person, zu best"atigen~\cite{rfc4480}.
Letztere erlauben es, ohne direkten (pers"onlichen) Austausch von Schl"usseln mit Personen
verschl"usselt zu kommunizieren, indem man erhaltene Schl"ussel "uber Unterschriften
durch Personen, die man bereits kennt, validiert.

OpenPGP definiert 17 verschiedene "`Packets"',%
\footnote{Die komplette Liste ist entweder mit Erkl"arungen im Standard~\cite{rfc4480}
oder ohne weitere Erl"auterung in \texttt{openpgp/common.py} ab Zeile 200 zu finden.}
die von "offentlichen oder privaten Schl"usseln "uber
"`User IDs"' bis zu verschl"usselten Daten verschiedensten Inhalt haben k"onnen.
Ein OpenPGP-formatierter Datensatz (also z.B.\@ eine verschl"usselte Nachricht, eigene private Schl"ussel,
"offentliche Schl"ussel von Bekannten, usw.\@) besteht aus einer Folge dieser Packets~\cite{rfc4480}.
So w"urde beispielsweise eine an zwei Personen verschl"usselte und unterschriebene Datei im OpenPGP-Format
zwei Packets mit dem asymmetrisch verschl"usselten symmetrischen Schl"ussel und einem Packet mit
verschl"usselten Daten, welches aus Packets f"ur die Datei und die Unterschrift
(sowie ggf.\@ einem weiteren Packet, welches Modifikationen der verschl"usselten Daten erkennbar machen soll)
besteht, enthalten. \todo{Bild?}

\subsection{Meine Implementation}
Was habe ich implementiert? Auf die hybride Krypto eingehen (AES als Unterpunkt?). Wenn erlaubt/noch Seiten "ubrig, auch auf Datenstrukturen eingehen (die wohl eher Richtung Mathe gehen als Packet-Format lesen usw.)
Wahrscheinlich auch viel aus dem OpenPGP-Standard zitieren.
\subsection{Beispiele}
Es funktioniert wirklich!

\section{Ausleitung}
Facharbeitshinweise:
\begin{quote}
Der Schluss sollte die Fragestellung aus der Einleitung aufgreifen und die wichtigsten Untersuchungsergebnisse zusammenfassen. Er kann den Untersuchungsgegenstand in größere Zusammenhänge einordnen und einen Ausblick auf künftige Entwicklungen enthalten. Auch kann hier das methodische Vorgehen kritisch reflektiert werden.
\end{quote}

\appendix

\section{kompletter Quellcode}

\section{Beispieldateien}

\section{weiteres Material}

\section{Literatur}

%! suppress = MightBreakTexify
\renewcommand{\section}[2]{}
\input{citations.tex}
\end{document}
