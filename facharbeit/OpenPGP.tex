\documentclass[12pt]{article}
\usepackage[german]{babel}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{stmaryrd}
\usepackage{xcolor}
\usepackage{setspace}
\usepackage[margin=2cm,left=4cm,marginparwidth=3cm]{geometry}
\usepackage{listings}
\usepackage{float}
\reversemarginpar

\lstset{
language=Python,
numbers=left,
keepspaces=true,
keywordstyle=\color{blue},
basicstyle=\footnotesize\ttfamily,
numberstyle=\tiny\color{gray}
}

\newfloat{code-snip}{htbp}{what_is_this}
\floatname{code-snip}{Quellcodeausschnitt}

% https://tex.stackexchange.com/a/30114
\setstretch{1.241}

\newcommand{\todo}[1]{\textcolor{red}{\mbox{TODO}}\marginpar{\textcolor{red}{#1}}}
\newcommand{\floor}[1]{\lfloor #1 \rfloor}

% https://tex.stackexchange.com/questions/23957/how-to-set-font-to-arial-throughout-the-entire-document
\renewcommand{\rmdefault}{phv} % Arial
\renewcommand{\sfdefault}{phv} % Arial

\title{Mathematische Hintergr\"unde und praktische Anwendung asymmetrischer Kryptographie am Beispiel von RSA und OpenPGP}
\input{pii.tex}

\begin{document}
\maketitle
\thispagestyle{empty}
\newpage
\tableofcontents
\newpage

\section{Einleitung}
% Asymmetrische Kryptographie ist toll. Damit kann man vieles machen (verschl"usseln, unterschreiben). [Bild von Wikipedia] Im "`digitalen Zeitalter"' ist das wichtig. (TLS, IoT). OpenPGP (Phil Zimmermann) ist neben S/MIME das Standardprotokoll f"ur krypto-behandelte E-Mails, hat aber auch z.B. WoT. Ich habe einen Teil davon implementiert.

\todo{Brauche ich f"ur diese Sachen Zitate?}

Traditionell waren Verschl"usselungsverfahren "`symmetrisch"', d.h., dass wie bei einem physichen Schloss
der gleiche Schl"ussel zur verschlie"sen (verschl"usseln) und zum Aufschlie"sen (Entschl"usseln) verwendet wird.
Der Ver\-schl"us\-sel\-ungs\-pro\-zess ist im Laufe der Zeit komplizierter geworden
(von der auch im Kopf m"oglichen Caesar-Verschl"usselung bis zur
maschinellen Verschl"usselung der Enigma w"ah\-rend des zweiten Weltkriegs),
jedoch hat es nie bis zuletzt
eine Abweichung vom Konzept eines einzigen Schl"ussels f"ur Ver- und Entschl"usselung gegeben.

Nach Entwicklung der Vorl"aufer des heutigen Internets wurde dann die asymmetrische Kryptographie erfunden.
Hier werden f"ur Ver- und Entschl"usselung separate Schl"ussel verwendet
(wie bei einem Vorh"angeschloss, wenn man das Schlie"sen als "`"offentlichen Schl"ussel"' betrachtet),
sodass Menschen verschl"usselt kom\-mu\-ni\-zie\-ren k"onnen, ohne vorher einen gemeinsamen Schl"ussel auszutauschen.
Neben Verschl"usselung von Nachrichten kann das Konzept asymmetrischer Kryptographie
auch f"ur digitale Unterschriften verwendet werden.

Der erste solche Verschl"usselungsalgorithmus, der auch in der Lage ist, Unterschriften zu erstellen und zu verifizieren, ist RSA.
Diesen m"ochte ich in dieser Arbeit n"aher betrachten und auch selbst implementieren.
RSA wird weiterhin in verschl"usselten Verbindungen mit gr"o"seren Seiten
wie etwa \texttt{wikipedia.org}, \\ \texttt{google.com} oder \piibigsite{} verwendet%
\footnote{Obwohl sowohl Google als auch Wikipedia inzwischen ECC-Schl"ussel verwenden,
sind die Schl"ussel der entsprechenden Root-CAs noch immer RSA-2048 (Stand \today)}.

Neben dieser Anwendung in TLS (der Kryptographie-Komponente\footnote{
TLS ist trotz dieser massiven Anwendung im WWW ein separates Protokoll und wird auch z.B. f"ur SMTPS oder FTPS (nicht mit SFTP zu verwechseln, welches "uber SSH l"auft) verwendet}
von HTTPS, dem Protokoll f"ur das WWW) wird RSA auch in OpenPGP,
welches auf dem 1991 von Phil Zimmermann ver"offentlichten PGP basiert und Einsatz bei der Ende-zu-Ende-Verschl"usselung
(d.h., dass nur Sender und Empf"anger den Inhalt lesen k"on\-nen)
von E-Mails findet, zur Verschl"usselung und f"ur Unterschriften verwendet.
W"ah\-rend sich OpenPGP auch mit der Vernetzung von Schl"usseln im Sinne eines sog. "`Web of Trust"' befasst,
habe ich mich bei meiner Teilimplementation haupts"achlich auf die durch RSA m"oglich gemachten
Funktionalit"aten konzentriert\footnote{Wobei nat"urlich Unterschriften "uber Schl"ussel f"ur das WoT wichtig sind, und ich somit diesen Teilaspekt mitimplementiert habe}.

\section{Mathe hinter RSA}
%Nachrichten und Schl"ussel sind Zahlen.
%Hier wahrscheinlich sehr viel aus dem RSA-Paper zitieren.

Mathematisch betrachtet besteht eine Nachricht aus einer Zahl und ein
Ver\-schl"us\-sel\-ungs\-al\-go\-rith\-mus aus zwei Funktionen.
Eine, im Folgenden $E(m)$, verwandelt unter Zuhilfenahme eines Schl"ussels eine
Nachricht in chiffrierten Text, eine zweite, im Folgenden $D(c)$,
verwandelt unter Zuhilfenahme eines anderen Schl"ussels -- dies ist der asymmetrische Teil --
den chiffrierten Text in die urspr"ungliche Nachricht.
Es gilt also $m = D(E(m))$.
Anders ausgedr"uckt: $D$ ist Umkehrfunktion von $E$~\cite{rsa}.
\todo{Hier irgendwo auch Unterschriften erw"ahnen?}

\subsection{Wie Schl"ussel aussehen}
\label{subsec:rsa:keys}
%Verh"altnis zwischen "offentlichem und privaten Exponenten.

Ein "offentlicher Schl"ussel besteht aus einem Paar nat"urlicher Zahlen $(e, n)$,
ein privater aus einem Paar nat"urlicher Zahlen $(d, n)$.
Dabei gilt, dass $n = pq$, das Produkt zweier ausreichend gro"ser Primzahlen~\cite{rsa}.

F"ur $e$ und $d$ gilt, dass $ed \equiv 1 \mod \phi(n)$,
wobei $\phi$ die eulersche Phi-Funktion darstellt, die nachfolgend n"aher erl"autert wird~\cite{rsa}.
Damit diese Kongruenz gelten kann, m"ussen $e$ und $d$ relativ prim zu $\phi(n)$ sein:
Wenn $d$ (analog f"ur $e$) einen gemeinsamen Faktor $f > 1 \in \mathbb{N}$ mit $\phi(n)$ teilte, m"usste Folgendes gelten:
\[
\begin{aligned}
&d = fa ~~;~~ \phi(n) = fb && \textrm{ mit } a, b \in \mathbb{N} \\
&efa \equiv 1 \mod fb \\
&efa = kfb + 1 && \textrm{f"ur ein bestimmtes } k \in \mathbb{N} \\
&ea = kb + \frac{1}{f} & \lightning &
\end{aligned}
\]
Da $ea$ und $kb$ als Produkte nat"urlicher Zahlen ebenfalls nat"urliche Zahlen sind, $\frac{1}{f}$ jedoch nicht, kommt es zum Widerspruch.

Am einfachsten ist es, einen geeigneten Wert f"ur $e$ festzulegen (z.B.\@ 65537)
und dann mittels des erweiterten Euklidschen Algorithmus (s.~unten) $d$ zu berechnen.

\subsubsection{Die eulersche Phi-Funktion}
Die eulersche Phi-Funktion $\phi(n)$ ordnet einer nat"urlichen Zahl $n$ die Anzahl der nat"urlichen Zahlen $\leq n$,
die relativ prim zu $n$ sind, zu.
F"ur eine Primzahl $p$ ist trivialerweise $\phi(p) = p-1$,
da jede nat"urliche Zahl $<p$ per Definition keine Faktoren bis auf $1$ mit $p$ teilt.
F"ur ein Produkt zweier Primzahlen $p$ und $q$ ist nach Euler
$\phi(pq) = \phi(p) \cdot \phi(q) = (p-1)(q-1)$~\cite{euler63}.

\subsubsection{Der erweiterte Euklidsche Algorithmus}
\todo{Schreiben. TAOCP2 S.~342f}

\subsection{Ver-/Entschl"usselungsprozess}
% Das hier wird wahrscheinlich "Uberschneidungen mit "`Wie Schl"ussel aussehen"' haben.
F"ur die Ver- und Entschl"usselungsfunktionen gilt~\cite{rsa}:
\[
\begin{aligned}
E(m) = m^e \mod n \\
D(c) = m^d \mod n
\end{aligned}
\]

Die G"ultigkeit dieser Funktionen wird nun erl"autert. \todo{So oder and\-ers\-her\-um?}

Nach Euler gilt $a^{b-1} \equiv 1 \mod b$ f"ur alle $b \in \mathbb{P}$ und $a \in \mathbb{N}$,
wenn $a$ nicht durch $b$ teilbar ist, also $a \not\equiv 0 \mod b$~\cite{euler41}.
Da $p$ (Faktor von $n$, s.~Abs.~\ref{subsec:rsa:keys}) prim ist,
gilt offensichtlich $a^{p-1} \equiv 1 \mod p$
(f"ur ein beliebiges $a$ wie oben beschrieben) und somit $m \cdot a^{p-1} \equiv m \mod p$.
Ersetzt man $a$ durch $m^{k \cdot (q-1)}$
(wobei $k \in \mathbb{N}$ und $q$ der zweite Faktor $n$s ist), erh"alt man~\cite{rsa}:
\[
\begin{aligned}
& m \cdot \left(m^{k(q-1)}\right)^{p-1} \\
\equiv & m \cdot m^{k(q-1)(p-1)} \\
\equiv & m \cdot m^{k\phi(n)} \\
\equiv & m^{k\phi(n) + 1} \\
\equiv & m \mod p
\end{aligned}
\]

Diese Kongruenz gilt weiterhin nur f"ur ein $a = m^{k(q-1)} \not\equiv 0 \mod p$.
Es ist jedoch offensichtlich, dass aus $m^{k(q-1)} \equiv 0 \mod p$ folgt,
dass $m \equiv 0 \mod p$ und somit $m^{k(q-1)} \equiv 0 \equiv m \mod p$.
Somit gilt $m^{k\phi(n)+1} \equiv m \mod p$ f"ur alle $m \in \mathbb{N}$~\cite{rsa}.\todo{So OK?}

Da aus $ed \equiv 1 \mod \phi(n)$ folgt, dass $ed = k\phi(n) +1$ f"ur ein $k \in \mathbb{N}$, gilt $m^{ed} \equiv m \mod p$.
Analog (durch Vertauschen von $p$ und $q$) kann gezeigt werden,
dass $m^{ed} \equiv m \mod q$ gilt~\cite{rsa}.

Aus diesen Kongruenzen lassen sich die folgenden beiden Gleichungen ableiten,
wobei $a, b \in \mathbb{N}$:

\[
\begin{aligned}
ap + m = m^{ed} \land ~~~ bq + m = m^{ed} \\
\iff m^{ed} - m = ap = bq
\end{aligned}
\]

Da $p$ und $q$ als Primzahlen keine Faktoren teilen, folgt aus $ap = bq$,
dass $a$ durch $q$ teilbar ist und $b$ durch $p$ teilbar ist.
Setzt man $c = \frac{a}{q} = \frac{b}{p}$ ($c \in \mathbb{N}$),
sieht man, dass $cn = m^{ed} - m$~\cite{pii1}.
Schreibt man diese Gleichung als Kongruenz, erh"alt man:

\[
m^{ed} \equiv m \mod n
\]

An dieser letzten Kongruenz sieht man, dass $D(E(m)) = (m^e)^d = m^{ed} \equiv m$,
die Ver- und Entschl"usselungsfunktionen also tats"achlich funktionieren.

\subsection{Cool! Damit kann man auch unterschreiben}

Die Ver- und Entschl"usselungsfunktionen lassen sich offensichtlich
auch verkehrt herum anwenden, ohne dass es zu Problemen kommt:
\[D(E(m)) = (m^e)^d = m^{ed} = (m^d)^e = E(D(m))\]
Obwohl dies zur Aufbewahrung geheimer Informationen offensichtlich suboptimal ist,
da der "offentliche Schl"ussel "offentlich sein soll, k"onnen damit Unterschriften erstellt werden.
Da nur jemand mit Zugang zu einem privaten Schl"ussel $s = D(m)$ berechnen kann,
kann man durch $E(s) = m$ verifizieren, dass $m$ tats"achlich vom
Inhaber des privaten Schl"ussels verschickt wurde.

\subsection{Sicherheit}

Kennt man die Faktoren $p$ und $q$, kann man leicht $\phi(n)$ und somit auch $d$ berechnen.
Die Faktorisierung wird jedoch schon seit Jahrtausenden untersucht,
ohne dass eine effiziente Methode gefunden wurde%
\footnote{f"ur Quantencomputer existieren effiziente Algorithmen,
jedoch wurden keine ausreichender Gr"o"se gebaut}~\cite{rsa}. \todo{Reichen die Beispiele hier?}

Die Berechnung von $\phi(n)$, ohne "uber die Faktoren zu gehen,
kann wie folgt in Kenntnis von $p$ und $q$ umgewandelt werden, sodass die Berechnung von $\phi(n)$
und die Faktorisierung $n$s \todo{Besser aussehen lassen} "aquivalent sind:

Kennt man $\phi(n)$, kann man "uber $\phi(n) = (p-1)(q-1) = n - (p+q) + 1$
die Summe $p+q$ berechnen.
Danach kann man mit $(p+q)^2 = p^2 + 2n + q^2 = p^2 - 2n + q^2 + 4n = (p-q)^2 + 4n$
die Differenz $p-q$ und folgend $q = \frac{(p+q) - (p-q)}{2}$ berechnet werden.
Dadurch hat man die Faktoren von $n$ berechnet~\cite{rsa}.

Trotz der "Aquivalenz zur Faktorisierung in diesem (und einigen weiteren,
hier nicht aufgef"uhrten F"allen, die in~\cite{rsa} genannt werden),
ist nicht automatisch jede Methode, die RSA bricht, eine M"oglichkeit
zur Faktorisierung~\cite{sinews}.
\todo{Die Quelle bezieht sich auf doi:10.1.1.73.7840, lieber direkt zitieren?}

\section{RSA praktisch implementieren}
% Bytes kann man einfach in Zahlen umwandeln, aber es geh"ort noch etwas mehr dazu

Ein offensichtlicher Unterschied zwischen den mathematischen Funktionen,
die RSA ausmachen, und praktischer Anwending ist, dass man praktisch entweder Dateien
oder Text und nicht Zahlen verschl"usseln will.
Dies ist jedoch nur das leichteste Problem, wenn RSA praktisch implementiert werden soll.
\todo{Mehr intro?}

\subsection{Effiziente Berechnung von $a^b \mod n$}
% Sonst w"are das alles viel zu langsam.

Da man sowohl zum Ver- als auch zum Entschl"usseln $a^b \mod n$ berechnen muss,
jedoch die jeweiligen Exponenten ($e$, $d$) in den allermeisten F"allen
in der Gr"o"senordnung von mindestens f"unf Stellen liegen
(der meistgenutzte "offentliche Exponent ist 65537%
\footnote{In GnuPG und OpenSSl Defaultwert,
und in \emph{jedem} RSA-Zertifikat, welches ich gesehen habe}),
ist es notwendig, modulare Exponentiation zu optimieren,
damit Ver- und Entschl"usselung praktikabel wird.

Um modulare Exponentiation zu verschnellern, kann man entweder weniger Multiplikationen
als $b-1$ durchf"uhren oder die durchgef"uhreten Multiplikationen schneller durchf"uhren.
Nat"urlich ist auch beides gleichzeitig m"oglich~\cite{hac}.

Ein allgemeiner Ansatz, Exponentiation zu verschnellern, ist sog.\@
"`repeated square and multiply"' ("`wiederholtes Quadrieren und Multiplizieren"').
In der einfachsten Form werden dabei alle $a^{(2^i)}$ multipliziert,
f"ur die das $i$te Bit in der binaren Darstellung von $b$ gleich $1$ ist.
Da man die Werte $a^{(2^i)}$ erhalten kann, indem man in jedem Schritt $a$ quadriert,
und die Multiplikationen auch schrittweise erfolgen k"onnen, (s.\@ Quellcodeausschnitt~\ref{code:square-and-multiply})
wird hier wiederholt quadriert und multipliziert.
Von diesem grundlegenen Algorithmus existieren Abwandlungen,
die durch noch weniger Multiplikationen mehr Effizienz erreichen.
Diese beschreibe ich allerdings nicht hier~\cite{hac}. \todo{Anhang?}

\begin{code-snip}
\begin{lstlisting}
def square_and_multiply_simple(a, b):
    ergebnis = 1
    for i in range(x.bit_length()):
        if 1 & b:
            ergebnis *= a
        a **= 2
        b >>= 1
    return ergebnis
\end{lstlisting}
\caption{Implementation eines simplen square-and-multiply-Algorithmus nach~\cite{hac}}
\label{code:square-and-multiply}
\end{code-snip}

Baut man die modulare Reduktion in die Multiplikation ein,
bleiben die zu multiplizierenden Zahlen klein, sodass die einzelnen
Multiplikationen schneller werden.
Auch hier existiert eine optimierte Variante, die sog.\@ "`Montgomery-Reduktion"'.
Dabei wird f"ur zwei ganze relativ prime Zahlen $m$ und $r$ sowie eine ganze Zahl $t$ mit $0 \leq t \le mr$
die kleinste nat"urliche Zahl, die kongruent zu $tr^{-1} \mod m$ ist, berechnet.
Dies kann bei man geschickter Wahl der zu multiplizierenden Zahlen
bei optimierten square-and-multiply-Algorithmen einsetzen.
\todo{Genau wie? Braucht aber ltr-algo}

In Python ist eine optimierte modulare Exponentiation als \lstinline{pow(a, b, n)} eingebaut.

\subsection{Primzahlen finden}
% Vielleicht den Teil hier auch in den Matheteil schieben. Auf jeden Fall im Anhang andere M"oglichkeiten auflisten.
Um Schl"ussel zu generieren, braucht man zun"achst Primzahlen.
Um diese Primzahlen zu erhalten, ist es aufgrund der Gr"o"se
(ab ca.\@ 1024 bits bzw.\@ 308 Ziffern)
inpraktikabel (darauf beruht die Sicherheit), alle Primzahlen zu finden.
Daher sieht die Prozedur zur Primzahlengeneration wie folgt aus~\cite{hac}: \todo{Fast 1 zu 1 "ubersetzt. Anders formatieren?}
\begin{itemize}
    \item Zuf"allige Zahl der gew"unschten Gr"o"se generieren
    \item Pr"ufen, ob die Zahl prim ist
    \item Fortfahren, bis eine Primzahl gefunden wurde
\end{itemize}

Zur Pr"ufung einer Primzahl existieren viele verschiedene Algorithmen.
Sie lassen sich grob in zwei Gruppen einteilen:
die probabilistischen, die mehrfach pr"ufen, ob eine Zahl zusammengesetzt ist,
und nach einer bestimmten Anzahl an Wiederholungen annehmen, dass die Zahl prim ist,
und die "`echten"', die tats"achlich beweisen k"onnen, dass eine Zahl prim ist~\cite{hac}.

Letztere sind generell komplexer, zeitaufw"andiger und funktionieren tw.\@ nur
f"ur spezielle Zahlen.
Zufallsabh"angige Tests k"onnen durch Wahl einer geeigneten Wiederholungszahl
auch hochverl"asslich gemacht werden.
Auch ist es m"oglich, ein hybrides Verfahren verwenden,
indem man zun"achst mit probabilistischen Tests
wahrscheinliche Primzahlen findet und dann mit komplexeren Tests
diese wenige Zahlen pr"uft~\cite{hac}.

\todo{Auch erkl"aren, welchen ich verwende?}

\subsection{Der PKCS\#1-Standard}
Warum man Padding benutzt. Entweder nur die f"ur OpenPGP benutzten Teile oder alles. Vielleicht auch nur die vorletzte Version.
\subsection{Meine Implementation}
\begin{itemize}
\item Schl"usselerstellung
\item (vielleicht) \verb|pow(a, b, n)| selbst schreiben? Ist zwar etwas bl"od, aber AES habe ich ja auch selbst geschrieben.
\item Zeigen, dass ein Grundlegener Ver-/Entschl"usselungs prozess buchst"ablich \verb|pow(text, *key)| ist
\item (vielleicht) auf das Padding eingehen.
\item Unterschriften
\end{itemize}

\section{OpenPGP}
\subsection{"Ubersicht}
Was macht OpenPGP?
Wahrscheinlich viel aus dem OpenPGP-Standard zitieren. Vielleicht finde ich auch noch etwas deskriptives au"ser Wikipedia.
\subsection{Meine Implementation}
Was habe ich implementiert? Auf die hybride Krypto eingehen (AES als Unterpunkt?). Wenn erlaubt/noch Seiten "ubrig, auch auf Datenstrukturen eingehen (die wohl eher Richtung Mathe gehen als Packet-Format lesen usw.)
Wahrscheinlich auch viel aus dem OpenPGP-Standard zitieren.
\subsection{Beispiele}
Es funktioniert wirklich!

\section{Ausleitung}
Facharbeitshinweise:
\begin{quote}
Der Schluss sollte die Fragestellung aus der Einleitung aufgreifen und die wichtigsten Untersuchungsergebnisse zusammenfassen. Er kann den Untersuchungsgegenstand in größere Zusammenhänge einordnen und einen Ausblick auf künftige Entwicklungen enthalten. Auch kann hier das methodische Vorgehen kritisch reflektiert werden.
\end{quote}

\appendix

\section{kompletter Quellcode}

\section{Beispieldateien}

\section{weiteres Material}

\section{Literatur}

%! suppress = MightBreakTexify
\renewcommand{\section}[2]{}
\input{citations.tex}
\end{document}
